

/******************** (C) COPYRIGHT  风驰电子嵌入式开发工作室 ***************************
  风驰电子STM8开发板硬件连接
    |--------------------|
    |  USART2_RX-PA4     |
    |  USART2_TX-PA5     |
    |--------------------|

****************************************************************************************/

#include "uart.h"
#include "stm8s.h"


/* ********************************************
UART1  configured as follow:
  - BaudRate = 115200 baud  
  - Word Length = 8 Bits
  - One Stop Bit
  - No parity
  - Receive and transmit enabled
 -  Receive interrupt
  - UART1 Clock disabled
*********************************************/

u8 RxBuffer[RxBufferSize];
u8 TxBuffer[TxBufferSize];
u8 UART_RX_NUM=0;
u8 Uart1_Rx_Flag=0;
u8 Uart1_Tx_Flag=0;


void Uart_Init(void)
{
  #ifdef USE_485
    GPIO_Init(RS485_PORT, RS485_PIN, GPIO_MODE_OUT_PP_LOW_FAST );
    RS485_RECEIVE_MOD;
  #endif

    UART1_DeInit();
    UART1_Init((u32)115200, UART1_WORDLENGTH_8D, UART1_STOPBITS_1, \
    UART1_PARITY_NO , UART1_SYNCMODE_CLOCK_DISABLE , UART1_MODE_TXRX_ENABLE);
    UART1_ITConfig(UART1_IT_RXNE_OR,ENABLE  );
    UART1_Cmd(ENABLE );
  
}

void UART1_SendByte(u8 data)
{
  #ifdef USE_485
    RS485_TRANSMIT_MOD;   //485 control 
  #endif  
    UART1_SendData8((unsigned char)data);
  /* Loop until the end of transmission */
  while (UART1_GetFlagStatus(UART1_FLAG_TXE) == RESET);
  #ifdef USE_485
    RS485_RECEIVE_MOD;   
  #endif  

}

void UART1_SendString(u8* Data,u16 len)
{
  u16 i=0;
  for(;i<len;i++)
    UART1_SendByte(Data[i]);
  
}

u8 UART1_ReceiveByte(void)
{
     u8 USART2_RX_BUF; 
     while (UART1_GetFlagStatus(UART1_FLAG_RXNE) == RESET);
     USART2_RX_BUF=UART1_ReceiveData8();
     return  USART2_RX_BUF;
    
}

char* itoa(int num,char* str,int radix)
{
    char index[]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";//索引表
    unsigned unum;//存放要转换的整数的绝对值,转换的整数可能是负数
    int i=0,j,k;//i用来指示设置字符串相应位，转换之后i其实就是字符串的长度；转换后顺序是逆序的，有正负的情况，k用来指示调整顺序的开始位置;j用来指示调整顺序时的交换。
 
    //获取要转换的整数的绝对值
    if(radix==10&&num<0)//要转换成十进制数并且是负数
    {
        unum=(unsigned)-num;//将num的绝对值赋给unum
        str[i++]='-';//在字符串最前面设置为'-'号，并且索引加1
    }
    else unum=(unsigned)num;//若是num为正，直接赋值给unum
 
    //转换部分，注意转换后是逆序的
    do
    {
        str[i++]=index[unum%(unsigned)radix];//取unum的最后一位，并设置为str对应位，指示索引加1
        unum/=radix;//unum去掉最后一位
 
    }while(unum);//直至unum为0退出循环
 
    str[i]='\0';//在字符串最后添加'\0'字符，c语言字符串以'\0'结束。
 
    //将顺序调整过来
    if(str[0]=='-') k=1;//如果是负数，符号不用调整，从符号后面开始调整
    else k=0;//不是负数，全部都要调整
 
    char temp;//临时变量，交换两个值时用到
    for(j=k;j<=(i-1)/2;j++)//头尾一一对称交换，i其实就是字符串的长度，索引最大值比长度少1
    {
        temp=str[j];//头部赋值给临时变量
        str[j]=str[i-1+k-j];//尾部赋值给头部
        str[i-1+k-j]=temp;//将临时变量的值(其实就是之前的头部值)赋给尾部
    }
 
    return str;//返回转换后的字符串
 
}


void UART1_ReciveIRQ(void)
{
    u8 Res;
    
    if(UART1_GetITStatus(UART1_IT_RXNE )!= RESET)  
    {
      
	Res =UART1_ReceiveData8();
        
              
        /*(USART1->DR);读取接收到的数据,当读完数据后自动取消RXNE的中断标志位*/
        if (UART_RX_NUM==0)
        {
            if (!(Res==0xEE))  UART_RX_NUM=0;             
        }
        else if (UART_RX_NUM==1)
        {
            if (!((Res==0x03)||(Res==0x02)))  UART_RX_NUM=0;
        }
        RxBuffer[ UART_RX_NUM]=Res ;
        UART_RX_NUM++;
        if( UART_RX_NUM>20)
        {
                UART_RX_NUM=0;
        }
        if ((UART_RX_NUM==RxBuffer[2])&&(RxBuffer[0]==0xEE)&&((RxBuffer[1]==0x03)||(RxBuffer[1]==0x02))&&(RxBuffer[UART_RX_NUM-1]==0xFF)&&(RxBuffer[UART_RX_NUM-2]==0x55))
         
        {
                UART_RX_NUM=0; 
                UART1_Rx_Flag=1;
        
        }	
    }
}

